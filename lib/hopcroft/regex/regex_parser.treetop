module Hopcroft
  module Regex
    grammar TreetopRegex do
      rule a_regex do
        car:expression cdr:expression* {
          def eval
            if cdr.elements.any?
              a = [car.eval, cdr.elements.map { |element| element.eval }]
              a.flatten!
              a.inject { |collection, element| collection + element }
            else
              car.eval
            end
          end
        }
      end

      rule expression do
        escaped_char / expr_without_escaping
      end

      rule expr_without_escaping do
        kleen_star / expr_without_kleen_star
      end

      rule expr_without_kleen_star do
        alternation / expr_without_alternation
      end

      rule expr_without_alternation do
        plus_expr / expr_without_plus
      end

      rule expr_without_plus do
        char_class / optional_expr / dot / chars
      end

      rule alternation do
        one:expr_without_alternation "|" two:expr_without_alternation {
          def eval
            Alternation.new(one.eval, two.eval)
          end
        }
      end

      rule plus_expr do
        expr_without_plus "+" {
          def eval
            Plus.new(expr_without_plus.eval)
          end
        }
      end

      rule char_class do
        "[" char_class_expr "]" {
          def eval
            CharacterClass.new(char_class_expr.text_value)
          end
        }
      end

      rule char_class_expr
        char "-" char
      end

      rule optional_expr do
        char "?" {
          def eval
            OptionalSymbol.new(char.eval)
          end
        }
      end

      rule kleen_star do
        expr_without_kleen_star "*" {
          def eval
            KleenStar.new(expr_without_kleen_star.eval)
          end
        }
      end

      rule dot do
        "." {
          def eval
            Dot.new
          end
        }
      end

      rule chars do
        char {
          def eval
            Char.new(text_value)
          end
        }
      end

      rule char do
        escape_char? char_without_escaping {
          def eval
            char_without_escaping.text_value
          end
        }
      end

      rule escaped_char do
        escape_char char_without_escaping {
          def eval
            Char.new(char_without_escaping.eval)
          end
        }
      end

      rule char_without_escaping do
        . { def eval; text_value; end }
      end

      rule escape_char do
        "\\"
      end
    end
  end
end
