module Hopcroft
  module Regex
    grammar TreetopRegex
      # expr -> expr "*"
      #      -> expr "+"
      #      -> expr expr  # concatenation
      #      -> "(" expr ")"
      #      -> /[a-zA-Z]+/
      #      
      # after left factorization:
      #      
      # expr -> "(" expr-prime ")"
      #      -> /[az-A-Z]/ expr-prime
      #      
      # expr-prime -> ""
      #            -> "*"
      #            -> "+"
      #            -> expr
      #            
      #
      # See http://en.wikipedia.org/wiki/Left_recursion#Removing_immediate_left_recursion
      
      rule regex
        LEFT_PARENS regex RIGHT_PARENS subexpression <SyntaxNodes::ParenthesizedSubexpression> /
        left_factored_expression       subexpression <SyntaxNodes::LeftFactoredExpression>
      end
      
      rule subexpression
        "*"       <SyntaxNodes::KleenStar>          /
        "+"       <SyntaxNodes::Plus>               /
        "?"       <SyntaxNodes::OptionalSymbol>     /
        "|" regex <SyntaxNodes::Alternation>        /
        regex     <SyntaxNodes::Concatenation>      /
        ""        <SyntaxNodes::Epsilon>
      end
      
      rule left_factored_expression
        dot / character_class / single_char
      end
      
      rule character_class
        LEFT_BRACKET inner_char_class RIGHT_BRACKET <SyntaxNodes::CharClass>
      end
      
      rule inner_char_class
        inner_char_class_expr+ <SyntaxNodes::MultipleInnerCharClassExpressions>
      end
      
      rule inner_char_class_expr
        one:single_char "-" two:single_char <SyntaxNodes::TwoCharClass> /
        single_char                         <SyntaxNodes::OneCharCharClass>
      end
      
      rule dot
        "." <SyntaxNodes::Dot>
      end
      
      rule single_char
        non_special_char / escaped_char
      end
      
      rule non_special_char
        !("(" / ")" / "[" / "+" / "?" / "+" / "]" / "|" / "*" / "\\") ANY_CHAR <SyntaxNodes::NonSpecialChar>
      end
      
      rule escaped_char
        ESCAPE any_char:ANY_CHAR <SyntaxNodes::EscapedChar>
      end
      
      rule ANY_CHAR
        .
      end
      
      rule LEFT_BRACKET
        "["
      end
      
      rule RIGHT_BRACKET
        "]"
      end
      
      rule ESCAPE
        "\\"
      end
      
      rule LEFT_PARENS
        "("
      end
      
      rule RIGHT_PARENS
        ")"
      end
    end
  end
end
